                             INGRESS CONTROLLER
                             ------------------
An Ingress Controller is a Kubernetes component that:
Exposes multiple services to the internet
Uses one Load Balancer
Routes traffic based on URL path or domain
Acts like a reverse proxy (NGINX) for Kubernetes
ğŸ‘‰ Without an ingress controller, every microservice needs its own LoadBalancer (very costly).

ğŸ”¹ Why Ingress Controller is Used (Real-Time)
Without Ingress
---------------
10 services â†’ 10 LoadBalancers	
High AWS cost	
No path routing
Hard to manage	

	With Ingress
  -----------
10 services â†’ 1 LoadBalancer
Low cost
Path & domain routing
Centralized control

                    to install nginx ingress controller
                    ----------------------------------
1ï¸âƒ£ Add Helm Repo

helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update

2ï¸âƒ£ Install Ingress Controller

helm install ingress-nginx ingress-nginx/ingress-nginx \
  --namespace ingress-nginx \
  --create-namespace

  3ï¸âƒ£ Verify

kubectl get pods -n ingress-nginx
kubectl get svc -n ingress-nginx

ğŸ”¹ How Kubernetes Automatically Creates LoadBalancer
â“ We never wrote a LoadBalancer YAML. How did it come?
âœ” Ingress controller includes this service:
kind: Service
type: LoadBalancer

Kubernetes:
Talks to cloud provider
Creates LB automatically
Attaches it to ingress pods

ğŸ”¹ DNS Mapping (Real-Time)
Once EXTERNAL-IP is ready:
app.company.com â†’ LoadBalancer IP

ğŸ”¹ CASE 1: Buy a New Domain in Route 53 (Beginner / Demo)
Example domain:
company.com

ğŸŸ¢ Step 1: Open Route 53
AWS Console â†’ Search Route 53
Amazon Route 53
ğŸŸ¢ Step 2: Register a Domain
Route 53 â†’ Registered domains â†’ Register domain
ğŸŸ¢ Step 3: Search Domain Name
Type:
company.com
If available â†’ select it â†’ continue
ğŸŸ¢ Step 4: Fill Contact Details
Owner name
Email
Address
(AWS requires this for domain registration)
ğŸŸ¢ Step 5: Pay & Register
Cost ~ â‚¹800â€“â‚¹1,200/year
Finish payment
â³ Takes 5â€“10 minutes
ğŸŸ¢ Step 6: Hosted Zone Created Automatically âœ…
After domain registration:
company.com

â¡ Route 53 automatically creates a Hosted Zone
Now you can select your domain ğŸ‰
ğŸ”¹ CASE 2: Domain Bought Outside (REAL-TIME COMPANY SCENARIO)
Most companies already have a domain.
Example:
company.com (bought from GoDaddy)

ğŸŸ¢ Step 1: Create Hosted Zone in Route 53
Route 53 â†’ Hosted zones â†’ Create hosted zone
Fill:
Field	Value
Domain name	company.com
Type	Public hosted zone
Click Create

ğŸŸ¢ Step 2: Copy Name Servers (IMPORTANT)
After creation, Route 53 gives 4 NS records like:
ns-123.awsdns-45.com
ns-678.awsdns-90.net

ğŸŸ¢ Step 3: Update Name Servers in Domain Provider
Go to GoDaddy / Namecheap â†’ DNS settings
Replace existing name servers with:
Route 53 NS records
â³ DNS propagation: 5â€“30 minutes (sometimes 24 hrs)

ğŸŸ¢ Step 4: Domain Now Managed by Route 53 âœ…
Now when you open:
Route 53 â†’ Hosted zones
You will see:
company.com
This is what â€œSelect your domainâ€ means.

ğŸ”¹ After Domain Exists â†’ Add Load Balancer
Now you can create:
app.company.com
By adding:
Record type: A
Alias: ON
Target: Ingress Load Balancer
(This is what we explained earlier)

ğŸ”¹ Visual Flow (Easy to Remember)
Buy/Create Domain
 â†“
Hosted Zone in Route 53
 â†“
Create DNS Record (app.company.com)
 â†“
Attach Load Balancer

ğŸ”¹ Interview Questions (Very Common)
Q: What is a Hosted Zone?

A: A container in Route 53 that holds DNS records for a domain.

Q: Can Kubernetes create a domain?

A: âŒ No, domains are managed outside Kubernetes.

Q: Who creates the domain in real projects?

A: Cloud/IT team, DevOps uses it.

ğŸ”¹ One-Line Summary (MEMORIZE)

First we create or import a domain into Route 53 as a hosted zone, then we attach the ingress load balancer using an A-Alias record.

                              
                                    Traffic Flow
                                   -------------
User â†’ DNS â†’ LoadBalancer â†’ NGINX Ingress Controller â†’ Services â†’ Pods

ğŸ”¹ Example: 3 Microservices (Real-Time)
We will deploy:
user-service â†’ /users
order-service â†’ /orders
product-service â†’ /products

All accessed via:
https://app.company.com

                          Deployment YAML (User Service)
                          -----------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-deployment
  namespace: prod
spec:
  replicas: 2
  selector:
    matchLabels:
      app: user
  template:
    metadata:
      labels:
        app: user
    spec:
      containers:
      - name: user-container
        image: myrepo/user-service:1.0
        ports:
        - containerPort: 8080
                                                      Service YAML (User Service)
                                                      ---------------------------
apiVersion: v1
kind: Service
metadata:
  name: user-service
  namespace: prod
spec:
  type: ClusterIP
  selector:
    app: user
  ports:
  - port: 80
    targetPort: 8080
    
Why port 80 here?
Service port (80) â†’ Ingress talks to service
targetPort (8080) â†’ Container port
âœ” Ingress never talks to container directly

NOTE;  same yml used for different services change as for requirements
       ex: in deployment.yml chnage this  name: user-deployment   app: user  
           in service.yml     change this  name: user-service     app: user
           for order service replace order in place of user remaing all or same  for all microservices

                                       Ingress YAML (One Ingress for All Services)
                                       --------------------------------------------
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: prod-ingress
  namespace: prod
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: app.company.com
    http:
      paths:
      - path: /users
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 80

      - path: /orders
        pathType: Prefix
        backend:
          service:
            name: order-service
            port:
              number: 80

      - path: /products
        pathType: Prefix
        backend:
          service:
            name: product-service
            port:
              number: 80

           
  
