1) Pods are Running & Healthy Service exists But application is NOT reachable (Connection Refused / Timeout).
---------------------------------------------------------------------------------------------------------------
 Check if Service is actually connected to Pods
 90% real issues are here
command : kubectl get endpoints <service-name>
Expected output ; IP:PORT    If you see  output as <none>
 Service is NOT connected to any pod.
 Root causes:
------------------------
A) Label mismatch â€“ what it REALLY means (realtime explanation)
In Kubernetes, Service does NOT connect to Pods automatically.
It connects ONLY using labels.
If labels donâ€™t match, traffic never reaches pods â€” even if pods are Running.
Labels mismatch
Wrong selector in Service
command: kubectl get pod --show-labels
         kubectl describe svc <service-name>
ğŸ”´ What is Label Mismatch?
ğŸ‘‰ Service selector â‰  Pod labels
So:
Pods are running âœ”
Service exists âœ”
BUT Service has NO endpoints âŒ
Result â†’ Connection refused / timeout
ğŸ§  Simple Realtime Example
------------------------------------
Pod (Deployment)                            
----------------                            
 metadata:                                 
  labels:
    app: backend                                
service
---------
selector:
  app: frontend   âŒ
âŒ Mismatch
Service is searching for pods with app=frontend
But pods have app=backend
â¡ Service finds ZERO pods

B) WRONG PORT
-------------
â€œWrong portâ€ means the Service is sending traffic to a port where the application is NOT listening.

So:
Pod is Running âœ”
Service exists âœ”
But traffic hits a closed port âŒ
â¡ Connection refused
ğŸ§  How Ports Work in Kubernetes (Very Important)

There are 3 different ports people confuse:

1ï¸âƒ£ containerPort â†’ where app runs inside Pod
2ï¸âƒ£ targetPort â†’ where Service forwards traffic
3ï¸âƒ£ port / nodePort â†’ where clients connect

ğŸ‘‰ targetPort MUST match containerPort

ğŸ”´ Realtime Example (Wrong Port)
Pod (App runs on 8080)
containers:
- name: app
  image: myapp
  ports:
  - containerPort: 8080
Service (WRONG)
ports:
- port: 80
  targetPort: 80   âŒ
âŒ Service sends traffic to port 80
âŒ App is listening on 8080
â¡ Connection refused

âœ… Correct Configuration
ports:
- port: 80
  targetPort: 8080   âœ”

ğŸ” How to Detect Wrong Port (Realtime)
1ï¸âƒ£ Check app port inside pod
COMMAND: kubectl describe pod <pod-name>
------
               or
       kubectl exec -it <pod> -- netstat -tulnp
âœ” Must show:

0.0.0.0:8080
2ï¸âƒ£ Check Service ports
COMMAND: kubectl describe svc <service-name>
3ï¸âƒ£ Check Endpoints
COMMAND : kubectl get endpoints <service-name>
If port is wrong â†’ endpoints exist but connection fails

C) âœ… Issue with Readiness Probe â€“ Realtime Kubernetes Explanation

Readiness probe issue means:
ğŸ‘‰ Pods are Running, but Kubernetes is NOT sending traffic to them
So:

Pod status = Running âœ”

Service exists âœ”

App still NOT reachable âŒ

ğŸ§  What Readiness Probe Does (Simple)
Readiness probe decides whether a pod is READY to receive traffic
If readiness fails:
Pod stays NotReady
Service removes pod from endpoints
Traffic is blocked

âŒ WRONG READINESS PROBE (Common Production Failures)
âŒ Case 1: Wrong Path (404 error)
readinessProbe:
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 5

Problem
--------
App exposes /ready
Probe hits /health
Returns 404
Pod becomes NotReady
Service endpoints = NONE
-------------------------------------------------------

âŒ Case 2: Wrong Port (Connection refused)
readinessProbe:
  httpGet:
    path: /ready
    port: 80   âŒ
Problem
---------
App runs on 8080
Probe checks 80
Connection refused
Pod never becomes ReaDY
---------------------------------------------------
âŒ Case 3: App starts slowly
readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 3   âŒ
Problem
--------
App takes 30s to start
Probe runs too early
Continuous failures
Traffic never reaches pod

âœ… CORRECT READINESS PROBE (Production Ready)
âœ… HTTP-based (Most common)

readinessProbe:
  httpGet:
    path: /ready    -----------        Endpoint used to check application readiness   ex: http://<pod-ip>:8080/ready

    port: 8080      ----------------   Port where the application listens inside the container. Must match: Application listening port ( container port)Wrong port = pod always NotReady
  initialDelaySeconds: 20  ------------- Kubernetes waits 20 seconds after container start before the first readiness check. Why:App needs time to:Start server,Load configs,Connect to DB.
  periodSeconds: 10  ---------------- Kubernetes checks readiness every 10 seconds 
  timeoutSeconds: 2  --------- Kubernetes waits 2 seconds for the /ready response If no response within 2 seconds:Probe fails, Pod marked NotReady
  failureThreshold: 3 ----------- Number of consecutive failures allowed 1st failure â†’ warning
                                                                         2nd failure â†’ warning
                                                                         3rd failure â†’ âŒ Pod marked NotReady
                                                                         ğŸ“Œ Traffic is removed only after 3 continuous failures

âœ” App fully started
âœ” Dependencies ready
âœ” Traffic allowed

ğŸ§  COMPLETE REALTIME FLOW
--------------------------------
Pod starts
â†“
Wait 20 seconds
â†“
Send HTTP GET /ready every 10 seconds
â†“
If response > 2 sec â†’ failure
â†“
If fails 3 times continuously â†’ traffic STOPPED
â†“
Pod continues running (no restart)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------






